---
title: "优酷-25届春季实习生-研发-第9批-0611"
author: 
date: 2024-06-11 20:45 +0800
categories: [Code, Interview]
tags: [math, array, hash]
math: true
mermaid: true
pin: false
img_path: /assets/img/posts/post_images/
---

2024 年 6 月 11 日 19:00 - 20:40，阿里大文娱（优酷） 2025 届研发笔试。



总限时 100 分钟，共 100 分。



前面是 15 道单选题，每题3分。



最后是三道算法题，分值分别为为 15/15/25 分。



编程题使用 ACM 模式，即需要自己处理输入输出。语言不限，**可以**用本地IDE（和其他阿里系不同）。



*Note: 试题回忆 / OCR 可能有错漏，且我的思路及解法较为笨拙，不敢保证正确性。*



抛砖引玉，敬请指正。



## 算法题

### Q1 小红买文具 15 pts

街上有 n 个文具店，第 i 个文具店售卖 y_i 个文具，每个文具的单价为 x_i 。

小红想买 m 个文具，她想知道最少需要花多少钱？

**输入描述**

第一行输入两个正整数n、m

接下来n行，每行输入两个正整数y_i、x_i，空格隔开。

1 <= n, m <= 10^5

1 <= y, x <= 10^5

所有y之和 >= m

**输出描述**

一个整数表示小红的最小花费。

**示例 1**

**输入**

```
3 2
1 1
1 2
1 3
```

**输出**

```
3
```

**说明**

```
前两个商店各买一个。
```



#### My Solution

简单模拟，通过100%

```python
from collections import defaultdict

n, m = map(int, input().split())
prices = defaultdict(int)
for _ in range(n):
    y, x = map(int, input().split())
    prices[x] += y
ans = 0
for pr in sorted(prices.keys()):
    cnt = prices[pr]
    if cnt >= m:
        ans += m * pr
        break
    else:
        ans += cnt * pr
        m -= cnt
print(ans)
```



### Q2 反转字符串 15 pts

小苯有一个长n的数组a，他可以对数组进行任意次以下两种操作：

- 选择1 ≤ i＜n，将a_i 和a_ (i+1) 合并为一个数字，结果为 a_i & a_(i+1)。（&表示按位与运算）
- 选择1 ≤ i＜n，将a_i 和a_ (i+1) 合并为一个数字，结果为 a_i \| a_(i+1)。（ 竖线表示按位或运算）

（两种操作均可以执行任意次，前提是数组长度至少为2。当然每次操作执行完后，n 都会减少1。）

小苯希望**最大化**数组的极差，请你帮帮他吧。

极差定义：数组最大值与最小值之间的差距。

**输入描述**

输入包含两行。

第一行一个正整数n （1 ≤ n ≤ 10^5），表示数组 a 的长度。

第二行 n 个整数 a_i（0 ≤  a_i ≤ 10^9），表示数组 a 的值。

**输出描述**

输出包含一行一个整数，表示数组的最大极差。

**示例 1**

**输入**

```
6
1 2 3 1 1 6
```

**输出**

```
7
```

**说明**

```
可以合并 a1 和 a2 为 a1 & a2，再合并 a5 和 a6 变为 a5 | a6。
此时数组变为：｛0, 3, 1, 7｝，极差为 7 最大。
可以证明不存在比 7 更大的极差。
```

#### My Solution

根据n、k的奇偶性分四类讨论。通过100%。

```python
n, k = map(int, input().split())
s = input().strip()
ans = ''
if n % 2 == 0:
    if k % 2 == 0:
        ans = s[k - 1:] + s[:k - 1][::-1]
    else:
        ans = s[k - 1:] + s[:k - 1]
else:
    if k % 2 != 0:
        ans = s[k - 1:] + s[:k - 1][::-1]
    else:
        ans = s[k - 1:] + s[:k - 1]
print(ans)
```



### Q3 小红的 red 重排 25 pts

小红拿到了一个长度为3*n的字符串，其中'red'三种字符都恰好有n个。

现在她每次操作可以交换任意两个字符，请你求出小红使得该字符串包含n个"red"连续子串的操作操作次数，并给出任意一个方案。

**输入描述**

第一行输入一个正整数n。

第二行输入一个长度为3*n的，由n个'r'、n个'e'、n个'd'组成的字符串。

1≤ n ≤ 50000

**输出描述**

第一行输入一个正整数 q ，代表操作次数。

接下来的 q 行、毎行输入两个正整数u、v，代表交换第 u 个字符和第 v 个字符。

**示例 1**

**输入**

```
1
edr
```

**输出**

```
2
1 3
2 3
```

**说明**

```
首先交换第一个字符和第三个字符，字符串变成"rde"。
然后交换第二个字符和第三个字符，字符串变成"red"。
```

**示例 2**

**输入**

```
3
redredred
```

**输出**

```
0
```



#### My Solution

没做。

```python
# TODO
```

#### Correct Solution

```python
# TODO
```

